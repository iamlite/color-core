---
id: color-in-data-visualization
title: "Color in Data Visualization"
description: "Learn how to use color-core to create effective and accessible color schemes for data visualization"
sidebar_label: "Data Visualization Colors"
keywords: [color-core, data visualization, color scales, accessibility, React]
---

import { Color } from 'color-core';
import { useState } from 'react';

# Color in Data Visualization

Data visualization is a crucial aspect of presenting information effectively. The right use of color can enhance understanding, highlight important data points, and improve overall readability. This guide will show you how to leverage color-core to create effective and accessible color schemes for your data visualizations.

## Creating Color Scales with color-core

color-core provides several functions that are particularly useful for creating color scales. Let's explore some of them with interactive examples.

### Sequential Color Scales

Sequential scales are ideal for representing data that ranges from low to high values. Here's how you can create a simple sequential scale using color-core:

```typescript
import { Color } from 'color-core';

function createSequentialScale(startColor: Color, endColor: Color, steps: number): Color[] {
  return Array.from({ length: steps }, (_, i) => 
    startColor.mix(endColor, i / (steps - 1))
  );
}

const lightBlue = new Color('#E3F2FD');
const darkBlue = new Color('#0D47A1');
const blueScale = createSequentialScale(lightBlue, darkBlue, 5);

console.log(blueScale.map(color => color.toHex()));
```

Here's an interactive example of this sequential scale:

export const SequentialScaleDemo = () => {
  const [startColor, setStartColor] = useState('#E3F2FD');
  const [endColor, setEndColor] = useState('#0D47A1');
  const [steps, setSteps] = useState(5);

  const createSequentialScale = (start, end, stepCount) => {
    const startCol = new Color(start);
    const endCol = new Color(end);
    return Array.from({ length: stepCount }, (_, i) =>
      startCol.mix(endCol, i / (stepCount - 1))
    );
  };

  const scale = createSequentialScale(startColor, endColor, steps);

  return (
    <div className="color-demo">
      <div>
        <label>
          Start Color:
          <input type="color" value={startColor} onChange={(e) => setStartColor(e.target.value)} />
        </label>
        <label>
          End Color:
          <input type="color" value={endColor} onChange={(e) => setEndColor(e.target.value)} />
        </label>
        <label>
          Steps:
          <input type="number" value={steps} onChange={(e) => setSteps(parseInt(e.target.value))} min="2" max="10" />
        </label>
      </div>
      <div className="swatch-container">
        {scale.map((color, index) => (
          <div key={index} className="color-swatch" style={{ backgroundColor: color.toHex() }} />
        ))}
      </div>
      <div>
        {scale.map((color, index) => (
          <div key={index}>{color.toHex()}</div>
        ))}
      </div>
    </div>
  );
};

<SequentialScaleDemo />

### Diverging Color Scales

Diverging scales are useful for data that has a meaningful midpoint. While color-core doesn't have a built-in function for this, we can create one using the existing `mix` method:

```typescript
import { Color } from 'color-core';

function createDivergingScale(startColor: Color, midColor: Color, endColor: Color, steps: number): Color[] {
  const halfSteps = Math.floor(steps / 2);
  const firstHalf = Array.from({ length: halfSteps }, (_, i) => 
    startColor.mix(midColor, i / (halfSteps - 1))
  );
  const secondHalf = Array.from({ length: steps - halfSteps }, (_, i) => 
    midColor.mix(endColor, i / (steps - halfSteps - 1))
  );
  return [...firstHalf, ...secondHalf.slice(1)];
}

const red = new Color('#EF5350');
const white = new Color('#FFFFFF');
const blue = new Color('#42A5F5');
const divergingScale = createDivergingScale(red, white, blue, 7);

console.log(divergingScale.map(color => color.toHex()));
```

Here's an interactive example of this diverging scale:

export const DivergingScaleDemo = () => {
  const [startColor, setStartColor] = useState('#EF5350');
  const [midColor, setMidColor] = useState('#FFFFFF');
  const [endColor, setEndColor] = useState('#42A5F5');
  const [steps, setSteps] = useState(7);

  const createDivergingScale = (start, mid, end, stepCount) => {
    const startCol = new Color(start);
    const midCol = new Color(mid);
    const endCol = new Color(end);
    const halfSteps = Math.floor(stepCount / 2);
    const firstHalf = Array.from({ length: halfSteps }, (_, i) =>
      startCol.mix(midCol, i / (halfSteps - 1))
    );
    const secondHalf = Array.from({ length: stepCount - halfSteps }, (_, i) =>
      midCol.mix(endCol, i / (stepCount - halfSteps - 1))
    );
    return [...firstHalf, ...secondHalf.slice(1)];
  };

  const scale = createDivergingScale(startColor, midColor, endColor, steps);

  return (
    <div className="color-demo">
      <div>
        <label>
          Start Color:
          <input type="color" value={startColor} onChange={(e) => setStartColor(e.target.value)} />
        </label>
        <label>
          Mid Color:
          <input type="color" value={midColor} onChange={(e) => setMidColor(e.target.value)} />
        </label>
        <label>
          End Color:
          <input type="color" value={endColor} onChange={(e) => setEndColor(e.target.value)} />
        </label>
        <label>
          Steps:
          <input type="number" value={steps} onChange={(e) => setSteps(parseInt(e.target.value))} min="3" max="11" step="2" />
        </label>
      </div>
      <div className="swatch-container">
        {scale.map((color, index) => (
          <div key={index} className="color-swatch" style={{ backgroundColor: color.toHex() }} />
        ))}
      </div>
      <div>
        {scale.map((color, index) => (
          <div key={index}>{color.toHex()}</div>
        ))}
      </div>
    </div>
  );
};

<DivergingScaleDemo />

## Ensuring Accessibility

When creating color scales for data visualization, it's crucial to ensure that your colors are distinguishable for all users, including those with color vision deficiencies. color-core provides methods to help with this:

```typescript
import { Color } from 'color-core';

function getContrastRatio(color1: Color, color2: Color): number {
  const l1 = color1.getBrightness();
  const l2 = color2.getBrightness();
  const ratio = (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
  return Number(ratio.toFixed(2));
}

const backgroundColor = new Color('#FFFFFF');
const textColor = new Color('#777777');
const contrastRatio = getContrastRatio(backgroundColor, textColor);

console.log(`Contrast ratio: ${contrastRatio}`);

// If the contrast isn't sufficient, you can adjust the colors:
const adjustedTextColor = textColor.adjustLightness(-20);
const newContrastRatio = getContrastRatio(backgroundColor, adjustedTextColor);

console.log(`New contrast ratio: ${newContrastRatio}`);
```

Here's an interactive example to check color contrast:

export const ContrastDemo = () => {
  const [color1, setColor1] = useState('#FFFFFF');
  const [color2, setColor2] = useState('#777777');

  const getContrastRatio = (col1, col2) => {
    const c1 = new Color(col1);
    const c2 = new Color(col2);
    const l1 = c1.getBrightness();
    const l2 = c2.getBrightness();
    const ratio = (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
    return Number(ratio.toFixed(2));
  };

  const contrastRatio = getContrastRatio(color1, color2);

  return (
    <div className="color-demo">
      <div>
        <label>
          Background Color:
          <input type="color" value={color1} onChange={(e) => setColor1(e.target.value)} />
        </label>
        <label>
          Text Color:
          <input type="color" value={color2} onChange={(e) => setColor2(e.target.value)} />
        </label>
      </div>
      <div style={{
        marginTop: '10px',
        padding: '20px',
        backgroundColor: color1,
        color: color2
      }}>
        Sample Text
      </div>
      <div>Contrast ratio: {contrastRatio}</div>
      <div>
        {contrastRatio >= 4.5 ? 'Passes AA' : 'Fails AA'} for normal text
      </div>
      <div>
        {contrastRatio >= 7 ? 'Passes AAA' : 'Fails AAA'} for normal text
      </div>
    </div>
  );
};

<ContrastDemo />

By leveraging color-core's color manipulation functions and these interactive tools, you can create sophisticated, accessible color schemes for your data visualizations. Remember to always test your color schemes with potential users and consider using tools that simulate different types of color blindness to ensure your visualizations are inclusive and effective.
